% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/swap_within_tick.R
\name{swap_within_tick}
\alias{swap_within_tick}
\title{Swap Within a Tick}
\usage{
swap_within_tick(
  L,
  sqrtpx96,
  dx = NULL,
  dy = NULL,
  decimal_x = 1000000000000000000,
  decimal_y = 1000000000000000000,
  fee = 0.003
)
}
\arguments{
\item{L}{active amount of liquidity in the pool, as big integer.
See get_liquidity() or read a pool contract's liquidity directly on etherscan to get this value.}

\item{sqrtpx96}{current price in uint160 format.
See price_to_sqrtpx96() or read a pool contract's sqrtPriceX96 within it's slot0 on etherscan to get this value.}

\item{dx}{the human readable amount of token 0 you are trading with the pool.
Otherwise, NULL if you are instead trading token 1.}

\item{dy}{NULL if you are trading token 0.
Otherwise, the human readable amount of token 1 you are trading with the pool.}

\item{decimal_x}{The decimals used in token 0, e.g., 1e18 for ETH, 1e6 for USDC.}

\item{decimal_y}{The decimals used in token 1, e.g., 1e6 for USDC, 1e8 for WBTC.}

\item{fee}{The pool fee, default 0.3\% (0.003). Generally one of: 0.0001, 0.0005, 0.003, 0.01}
}
\value{
Swap functions return lists. For a token 0 -> token 1 swap a list of:
\item{liquidity}{amount of liquidity in the pool after the trade (will always match L in swap_within_tick())}
\item{dx}{ the amount of token 0 added (i.e. sold by user) to the pool (FEES separated)}
\item{dy}{ the amount of token 1 removed (i.e. bought by user) from the pool}
\item{price1}{ the initial sqrtpx96 price of the pool before the swap}
\item{price2}{ the final sqrtpx96 price of the pool after the swap}
\item{fee}{ the fee taken by the pool, in the unit of token added to the pool (input dx = returned dx + fee)}
}
\description{
This function calculates the amount of assets coming out of a trade from a pool
given the active Liquidity, the current price, the amounts of each asset, and the pool fee.
For simplicity it supports decimal separation to retain human readable swaps.
}
\details{
This function assumes the amounts traded do not cause a recalculation of active liquidity.
If you have access to all available positions in a pool (including those out of range that may become in-range during a swap)
you should instead use swap_across_ticks().
This function should be within tolerable precision loss for small swaps on deep pools if
the positions table is not available.
}
\examples{
# Trading LINK for MKR on an Optimism pool.
# see ?get_liquidity
L = '343255264548669212'
# see ?price_to_sqrtpx96
P = 0.009264495
swap_within_tick(L = L,
sqrtpx96 = price_to_sqrtpx96(P),
dx = 0.000000030675491064, # selling tiny amount of LINK
dy = NULL, # how much MKR will be returned?
decimal_x = 1e18, # LINK has 18 decimals
decimal_y = 1e18, # MKR has 18 decimals
fee = 0.003) # 0.3\% pool
}
