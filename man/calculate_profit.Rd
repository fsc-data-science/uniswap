% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calculate_profit.R
\name{calculate_profit}
\alias{calculate_profit}
\title{Calculate Profit}
\usage{
calculate_profit(
  params,
  budget = 100,
  p1,
  p2,
  trades,
  decimal_x = 1e+18,
  decimal_y = 1e+18,
  fee = 0.003,
  denominate = 1,
  in_optim = FALSE
)
}
\arguments{
\item{params}{array of (amount of Token 1, price_lower). Using price instead of tick improves optimization.
Use ?tick_to_price to convert accordingly.}

\item{budget}{max amount of Token 1 possible.}

\item{p1}{Exchange rate for Token 1 / Token 0 for calculating amount0 and liquidity at the beginning of a position.}

\item{p2}{The market price or final price for assessing the strategy value of a position after trades.}

\item{trades}{Trades table with columns tick, amount0_adjusted, amount1_adjusted, liquidity, see ?ethwbtc_trade_history for an example.
Negative (tokens bought) and Positive (tokens sold by user to pool) are expected in one of amount0_adjusted or amount1_adjusted.}

\item{decimal_x}{The decimals used in token 0, e.g., 1e6 for USDC, 1e8 for WBTC.}

\item{decimal_y}{The decimals used in token 1, e.g., 1e18 for WETH.}

\item{fee}{The pool fee, default 0.3\% (0.003). Generally one of: 0.0001, 0.0005, 0.003, 0.01}

\item{denominate}{Denominate the result of the strategy in Token 0, `0`, or Token 1, `1`. Default 1.}

\item{in_optim}{Default FALSE returns all data from calculating a position's value. TRUE returns only -1*sv$value for iterating through optim() optimization.}
}
\value{
A list of all available information about a position after select trades, or -sv$value if in_optim = TRUE.
}
\description{
This is a wrapper function to ?calc_strategy_value that tailored for optimization.
It can create a hypothetical position and calculate its marginal liquidity to assess fees from trades
using price, amount1, and budget (in amount1) to calculate amount0 and tick_lower combined with ?price_all_tokens to
get the tick_upper. This enables 2-parameter optimization to get all relevant details of a position. Note,
the optimal results may not fit all pools and tick spacings. Use ?get_closest_tick as needed to get near-optimal allowed
ranges.
}
\examples{
data("ethwbtc_trade_history")
block_min = 16000000
block_max = 16010000
trades_16m10k <- ethwbtc_trade_history[ethwbtc_trade_history$block_number \%in\% (block_min:block_max), ]


# Given initial & final prices
# as the first and last prices in the relevant swaps
p1 = tick_to_price(tick = head(trades_16m10k$tick, n = 1), decimal_adjustment = 1e10)
p2 = tick_to_price(tick = tail(trades_16m10k$tick, n = 1), decimal_adjustment = 1e10)

# Initial 50 ETH as amount0 & price_lower at 25\% of current price
price_lower <- 0.25 * p1
init_params <- c(50, 2*price_lower)

# Define lower and upper bounds for ETH and price_lower
# amount1 is 0.01 - 99.9
# price_lower is 0.5 ETH/BTC - 0.999*P1
lower_bounds <- c(0.01, 0.5)
upper_bounds <- c(99.9, 0.999*p1)

# maximize profit using L-BFGS-B and select trades
# denominate in ETH
result <- optim(init_params,
                calculate_profit,
                method = "L-BFGS-B",
                lower = lower_bounds,
                upper = upper_bounds, budget = 100, p1 = p1, p2 = p2, trades = trades_16m10k,
                decimal_x = 1e8, decimal_y = 1e18, fee = 0.003, denominate = 1, in_optim = TRUE)

# results
calculate_profit(params = result$par,
                 budget = 100, p1 = p1, p2 = p2, trades = trades_16m10k,
                 decimal_x = 1e8, decimal_y = 1e18, fee = 0.003, denominate = 1, in_optim = FALSE)
}
